# Professional Guide: Connecting Flutter to Laravel API

This document provides an in-depth, step-by-step breakdown of the professional architecture used to connect the Bellavella Flutter frontend to its Laravel backend. This approach ensures scalability, maintainability, and a premium user experience.

---

## üèó The Architecture: "The Layered Approach"

We don't make API calls directly from the UI. Instead, we use a 4-layer system to keep concerns separated.

### 1. The Configuration Layer (`lib/core/config/`)
**Purpose**: Centralize all "Magic Strings" and environment variables.
- **File**: `app_config.dart`
- **Standard Practice**: Define a `static const String baseUrl`.
- **Why?**: If you move your server from a local dev machine to a production server (AWS/DigitalOcean), you only change **one line** of code instead of searching through 50 files.

### 2. The Core Service Layer (`lib/core/services/`)
**Purpose**: The "Engine" for networking.
- **File**: `api_service.dart`
- **Mechanism**: Standardizes shared logic for **every** request.
- **Best Practices**:
    - **Header Management**: Always include `'Accept': 'application/json'` so Laravel knows to send JSON, not HTML.
    - **JSON Envelope Parsing**: Use the structure defined in your Laravel `BaseController` (`success`, `message`, `data`).
    - **Global Error Handling**: Wrap calls in `try-catch` to handle "No Internet" (SocketException) or "Server Down" errors once, in one place.

### 3. The Feature Service Layer (`lib/features/x/services/`)
**Purpose**: Domain logic for a specific feature.
- **File Example**: `auth_api_service.dart`
- **Responsibility**: Map frontend actions to backend endpoints.
- **Best Practice**: This layer is "dumb" about HTTP. It simply tells the `ApiService`: "Go to this endpoint with these parameters."

### 4. The UI Layer (The Implementation)
**Purpose**: Consume data and manage user state.
- **Best Practice Pattern**:
    1. **Loading State**: Use a `bool _isLoading` to show a spinner. This prevents "double-clicks" on buttons.
    2. **Async Gaps**: After an `await`, always check `if (!mounted)` before updating the UI or navigating. This prevents "late initialization" crashes.
    3. **Envelop-Aware Feedback**: Use the `message` from the API response in your `SnackBar` so the user knows exactly why a request failed (e.g., "Phone number already exists").

---

## üõ† Step-by-Step implementation Workflow

### Step 1: Add Dependencies
Add `http` to `pubspec.yaml`. It's the standard for professional Flutter apps.

### Step 2: Set the Base URL
In `app_config.dart`:
```dart
static const String baseUrl = 'http://127.0.0.1:8000/api';
```

### Step 3: Implement the Core ApiService
This class should handle the JSON decoding and status checks.
```dart
// Example core logic
static Future<Map<String, dynamic>> post(String endpoint, Map body) async {
  final res = await http.post(Uri.parse(baseUrl + endpoint), body: jsonEncode(body));
  return jsonDecode(res.body);
}
```

### Step 4: Create the Feature Service
Define the specific endpoint for the feature you are working on.
```dart
class AuthApiService {
  static Future<Map> sendOtp(String mobile) {
    return ApiService.post('/flutter/auth/send-otp', {'mobile': mobile});
  }
}
```

### Step 5: Connect to the UI
Implement the logic in your `StatefulWidget`.
```dart
Future<void> _handleAction() async {
  setState(() => _isLoading = true);
  try {
    final res = await AuthApiService.sendOtp(phone);
    if (res['success']) {
       // Success logic
    } else {
       // Error logic
    }
  } finally {
    if (mounted) setState(() => _isLoading = false);
  }
}
```

---

## üåü Pro Tips for Best Standards

- **Never logic in UI**: If you are writing `jsonEncode` inside a `Screen`, you are doing it wrong. Move it to a Service.
- **Standardized Backend**: Ensure your Laravel `BaseController` always returns the same JSON shape. This makes your Flutter parsing predictable.
- **User-Centric**: Always use `isLoading` to disable buttons during requests. Users hate clicking a button and seeing nothing happen.
- **Linter Compliance**: Use `mounted` checks religiously. It shows you care about stability and memory management.

---

### Project Structure Recap
```text
lib/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ config/ (Base URLs)
‚îÇ   ‚îî‚îÄ‚îÄ services/ (JSON Engine)
‚îî‚îÄ‚îÄ features/
    ‚îî‚îÄ‚îÄ [feature_name]/
        ‚îú‚îÄ‚îÄ services/ (API Routes)
        ‚îî‚îÄ‚îÄ [feature]_screen.dart (UI Implementation)
```
